{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Auto-GPT Welcome to Auto-GPT. Please follow the Installation guide to get started. It is recommended to use a virtual machine for tasks that require high security measures to prevent any potential harm to the main computer's system and data.","title":"Home"},{"location":"#auto-gpt","text":"Welcome to Auto-GPT. Please follow the Installation guide to get started. It is recommended to use a virtual machine for tasks that require high security measures to prevent any potential harm to the main computer's system and data.","title":"Auto-GPT"},{"location":"code-of-conduct/","text":"Code of Conduct for Auto-GPT 1. Purpose The purpose of this Code of Conduct is to provide guidelines for contributors to the auto-gpt project on GitHub. We aim to create a positive and inclusive environment where all participants can contribute and collaborate effectively. By participating in this project, you agree to abide by this Code of Conduct. 2. Scope This Code of Conduct applies to all contributors, maintainers, and users of the auto-gpt project. It extends to all project spaces, including but not limited to issues, pull requests, code reviews, comments, and other forms of communication within the project. 3. Our Standards We encourage the following behavior: Being respectful and considerate to others Actively seeking diverse perspectives Providing constructive feedback and assistance Demonstrating empathy and understanding We discourage the following behavior: Harassment or discrimination of any kind Disrespectful, offensive, or inappropriate language or content Personal attacks or insults Unwarranted criticism or negativity 4. Reporting and Enforcement If you witness or experience any violations of this Code of Conduct, please report them to the project maintainers by email or other appropriate means. The maintainers will investigate and take appropriate action, which may include warnings, temporary or permanent bans, or other measures as necessary. Maintainers are responsible for ensuring compliance with this Code of Conduct and may take action to address any violations. 5. Acknowledgements This Code of Conduct is adapted from the Contributor Covenant . 6. Contact If you have any questions or concerns, please contact the project maintainers.","title":"Code of Conduct"},{"location":"code-of-conduct/#code-of-conduct-for-auto-gpt","text":"","title":"Code of Conduct for Auto-GPT"},{"location":"code-of-conduct/#1-purpose","text":"The purpose of this Code of Conduct is to provide guidelines for contributors to the auto-gpt project on GitHub. We aim to create a positive and inclusive environment where all participants can contribute and collaborate effectively. By participating in this project, you agree to abide by this Code of Conduct.","title":"1. Purpose"},{"location":"code-of-conduct/#2-scope","text":"This Code of Conduct applies to all contributors, maintainers, and users of the auto-gpt project. It extends to all project spaces, including but not limited to issues, pull requests, code reviews, comments, and other forms of communication within the project.","title":"2. Scope"},{"location":"code-of-conduct/#3-our-standards","text":"We encourage the following behavior: Being respectful and considerate to others Actively seeking diverse perspectives Providing constructive feedback and assistance Demonstrating empathy and understanding We discourage the following behavior: Harassment or discrimination of any kind Disrespectful, offensive, or inappropriate language or content Personal attacks or insults Unwarranted criticism or negativity","title":"3. Our Standards"},{"location":"code-of-conduct/#4-reporting-and-enforcement","text":"If you witness or experience any violations of this Code of Conduct, please report them to the project maintainers by email or other appropriate means. The maintainers will investigate and take appropriate action, which may include warnings, temporary or permanent bans, or other measures as necessary. Maintainers are responsible for ensuring compliance with this Code of Conduct and may take action to address any violations.","title":"4. Reporting and Enforcement"},{"location":"code-of-conduct/#5-acknowledgements","text":"This Code of Conduct is adapted from the Contributor Covenant .","title":"5. Acknowledgements"},{"location":"code-of-conduct/#6-contact","text":"If you have any questions or concerns, please contact the project maintainers.","title":"6. Contact"},{"location":"contributing/","text":"This document now lives at https://github.com/Significant-Gravitas/Auto-GPT/wiki/Contributing","title":"Contribution guide"},{"location":"plugins/","text":"Plugins \u26a0\ufe0f\ud83d\udc80 WARNING \ud83d\udc80\u26a0\ufe0f: Review the code of any plugin you use thoroughly, as plugins can execute any Python code, potentially leading to malicious activities, such as stealing your API keys. See our Plugins Repo for more info on how to install all the amazing plugins the community has built! Alternatively, developers can use the Auto-GPT Plugin Template as a starting point for creating your own plugins.","title":"Plugins"},{"location":"plugins/#plugins","text":"\u26a0\ufe0f\ud83d\udc80 WARNING \ud83d\udc80\u26a0\ufe0f: Review the code of any plugin you use thoroughly, as plugins can execute any Python code, potentially leading to malicious activities, such as stealing your API keys. See our Plugins Repo for more info on how to install all the amazing plugins the community has built! Alternatively, developers can use the Auto-GPT Plugin Template as a starting point for creating your own plugins.","title":"Plugins"},{"location":"setup/","text":"Setting up Auto-GPT \ud83d\udccb Requirements Choose an environment to run Auto-GPT in (pick one): Docker ( recommended ) Python 3.10 or later (instructions: for Windows ) VSCode + devcontainer \ud83d\udddd\ufe0f Getting an API key Get your OpenAI API key from: https://platform.openai.com/account/api-keys . Attention To use the OpenAI API with Auto-GPT, we strongly recommend setting up billing (AKA paid account). Free accounts are limited to 3 API calls per minute, which can cause the application to crash. You can set up a paid account at Manage account > Billing > Overview . Important It's highly recommended that you keep track of your API costs on the Usage page . You can also set limits on how much you spend on the Usage limits page . Setting up Auto-GPT Set up with Docker Make sure you have Docker installed, see requirements Pull the latest image from Docker Hub docker pull significantgravitas/auto-gpt Create a folder for Auto-GPT In the folder, create a file called docker-compose.yml with the following contents: version : \"3.9\" services : auto-gpt : image : significantgravitas/auto-gpt depends_on : - redis env_file : - .env environment : MEMORY_BACKEND : ${MEMORY_BACKEND:-redis} REDIS_HOST : ${REDIS_HOST:-redis} profiles : [ \"exclude-from-up\" ] volumes : - ./auto_gpt_workspace:/app/autogpt/auto_gpt_workspace - ./data:/app/data ## allow auto-gpt to write logs to disk - ./logs:/app/logs ## uncomment following lines if you have / want to make use of these files #- ./azure.yaml:/app/azure.yaml #- ./ai_settings.yaml:/app/ai_settings.yaml redis : image : \"redis/redis-stack-server:latest\" Create the necessary configuration files. If needed, you can find templates in the repository . Continue to Run with Docker Docker only supports headless browsing Auto-GPT uses a browser in headless mode by default: HEADLESS_BROWSER=True . Please do not change this setting in combination with Docker, or Auto-GPT will crash. Set up with Git Important Make sure you have Git installed for your OS. Executing commands To execute the given commands, open a CMD, Bash, or Powershell window. On Windows: press Win + X and pick Terminal , or Win + R and enter cmd Clone the repository git clone -b stable https://github.com/Significant-Gravitas/Auto-GPT.git Navigate to the directory where you downloaded the repository cd Auto-GPT Set up without Git/Docker Warning We recommend to use Git or Docker, to make updating easier. Download Source code (zip) from the latest stable release Extract the zip-file into a folder Configuration Find the file named .env.template in the main Auto-GPT folder. This file may be hidden by default in some operating systems due to the dot prefix. To reveal hidden files, follow the instructions for your specific operating system: Windows , macOS . Create a copy of .env.template and call it .env ; if you're already in a command prompt/terminal window: cp .env.template .env . Open the .env file in a text editor. Find the line that says OPENAI_API_KEY= . After the = , enter your unique OpenAI API Key without any quotes or spaces . Enter any other API keys or tokens for services you would like to use. Note To activate and adjust a setting, remove the # prefix. Save and close the .env file. Using a GPT Azure-instance If you want to use GPT on an Azure instance, set USE_AZURE to True and make an Azure configuration file: Rename azure.yaml.template to azure.yaml and provide the relevant azure_api_base , azure_api_version and all the deployment IDs for the relevant models in the azure_model_map section: fast_llm_model_deployment_id : your gpt-3.5-turbo or gpt-4 deployment ID smart_llm_model_deployment_id : your gpt-4 deployment ID embedding_model_deployment_id : your text-embedding-ada-002 v2 deployment ID Example: # Please specify all of these values as double-quoted strings # Replace string in angled brackets (<>) to your own ID azure_model_map : fast_llm_model_deployment_id : \"<my-fast-llm-deployment-id>\" ... Details can be found in the openai-python docs , and in the Azure OpenAI docs for the embedding model. If you're on Windows you may need to install an MSVC library . Running Auto-GPT Run with Docker Easiest is to use docker-compose . Important: Docker Compose version 1.29.0 or later is required to use version 3.9 of the Compose file format. You can check the version of Docker Compose installed on your system by running the following command: docker-compose version This will display the version of Docker Compose that is currently installed on your system. If you need to upgrade Docker Compose to a newer version, you can follow the installation instructions in the Docker documentation: https://docs.docker.com/compose/install/ Once you have a recent version of docker-compose, run the commands below in your Auto-GPT folder. Build the image. If you have pulled the image from Docker Hub, skip this step. docker-compose build auto-gpt Run Auto-GPT docker-compose run --rm auto-gpt By default, this will also start and attach a Redis memory backend. If you do not want this, comment or remove the depends: - redis and redis: sections from docker-compose.yml . For related settings, see Memory > Redis setup . You can pass extra arguments, e.g. running with --gpt3only and --continuous : docker-compose run --rm auto-gpt --gpt3only --continuous If you dare, you can also build and run it with \"vanilla\" docker commands: docker build -t auto-gpt . docker run -it --env-file = .env -v $PWD :/app auto-gpt docker run -it --env-file = .env -v $PWD :/app --rm auto-gpt --gpt3only --continuous Run with Dev Container Install the Remote - Containers extension in VS Code. Open command palette with F1 and type Dev Containers: Open Folder in Container . Run ./run.sh . Run without Docker Simply run the startup script in your terminal. This will install any necessary Python packages and launch Auto-GPT. On Linux/MacOS: ./run.sh On Windows: . \\r un.bat If this gives errors, make sure you have a compatible Python version installed. See also the requirements .","title":"Setup"},{"location":"setup/#setting-up-auto-gpt","text":"","title":"Setting up Auto-GPT"},{"location":"setup/#requirements","text":"Choose an environment to run Auto-GPT in (pick one): Docker ( recommended ) Python 3.10 or later (instructions: for Windows ) VSCode + devcontainer","title":"\ud83d\udccb Requirements"},{"location":"setup/#getting-an-api-key","text":"Get your OpenAI API key from: https://platform.openai.com/account/api-keys . Attention To use the OpenAI API with Auto-GPT, we strongly recommend setting up billing (AKA paid account). Free accounts are limited to 3 API calls per minute, which can cause the application to crash. You can set up a paid account at Manage account > Billing > Overview . Important It's highly recommended that you keep track of your API costs on the Usage page . You can also set limits on how much you spend on the Usage limits page .","title":"\ud83d\udddd\ufe0f Getting an API key"},{"location":"setup/#setting-up-auto-gpt_1","text":"","title":"Setting up Auto-GPT"},{"location":"setup/#set-up-with-docker","text":"Make sure you have Docker installed, see requirements Pull the latest image from Docker Hub docker pull significantgravitas/auto-gpt Create a folder for Auto-GPT In the folder, create a file called docker-compose.yml with the following contents: version : \"3.9\" services : auto-gpt : image : significantgravitas/auto-gpt depends_on : - redis env_file : - .env environment : MEMORY_BACKEND : ${MEMORY_BACKEND:-redis} REDIS_HOST : ${REDIS_HOST:-redis} profiles : [ \"exclude-from-up\" ] volumes : - ./auto_gpt_workspace:/app/autogpt/auto_gpt_workspace - ./data:/app/data ## allow auto-gpt to write logs to disk - ./logs:/app/logs ## uncomment following lines if you have / want to make use of these files #- ./azure.yaml:/app/azure.yaml #- ./ai_settings.yaml:/app/ai_settings.yaml redis : image : \"redis/redis-stack-server:latest\" Create the necessary configuration files. If needed, you can find templates in the repository . Continue to Run with Docker Docker only supports headless browsing Auto-GPT uses a browser in headless mode by default: HEADLESS_BROWSER=True . Please do not change this setting in combination with Docker, or Auto-GPT will crash.","title":"Set up with Docker"},{"location":"setup/#set-up-with-git","text":"Important Make sure you have Git installed for your OS. Executing commands To execute the given commands, open a CMD, Bash, or Powershell window. On Windows: press Win + X and pick Terminal , or Win + R and enter cmd Clone the repository git clone -b stable https://github.com/Significant-Gravitas/Auto-GPT.git Navigate to the directory where you downloaded the repository cd Auto-GPT","title":"Set up with Git"},{"location":"setup/#set-up-without-gitdocker","text":"Warning We recommend to use Git or Docker, to make updating easier. Download Source code (zip) from the latest stable release Extract the zip-file into a folder","title":"Set up without Git/Docker"},{"location":"setup/#configuration","text":"Find the file named .env.template in the main Auto-GPT folder. This file may be hidden by default in some operating systems due to the dot prefix. To reveal hidden files, follow the instructions for your specific operating system: Windows , macOS . Create a copy of .env.template and call it .env ; if you're already in a command prompt/terminal window: cp .env.template .env . Open the .env file in a text editor. Find the line that says OPENAI_API_KEY= . After the = , enter your unique OpenAI API Key without any quotes or spaces . Enter any other API keys or tokens for services you would like to use. Note To activate and adjust a setting, remove the # prefix. Save and close the .env file. Using a GPT Azure-instance If you want to use GPT on an Azure instance, set USE_AZURE to True and make an Azure configuration file: Rename azure.yaml.template to azure.yaml and provide the relevant azure_api_base , azure_api_version and all the deployment IDs for the relevant models in the azure_model_map section: fast_llm_model_deployment_id : your gpt-3.5-turbo or gpt-4 deployment ID smart_llm_model_deployment_id : your gpt-4 deployment ID embedding_model_deployment_id : your text-embedding-ada-002 v2 deployment ID Example: # Please specify all of these values as double-quoted strings # Replace string in angled brackets (<>) to your own ID azure_model_map : fast_llm_model_deployment_id : \"<my-fast-llm-deployment-id>\" ... Details can be found in the openai-python docs , and in the Azure OpenAI docs for the embedding model. If you're on Windows you may need to install an MSVC library .","title":"Configuration"},{"location":"setup/#running-auto-gpt","text":"","title":"Running Auto-GPT"},{"location":"setup/#run-with-docker","text":"Easiest is to use docker-compose . Important: Docker Compose version 1.29.0 or later is required to use version 3.9 of the Compose file format. You can check the version of Docker Compose installed on your system by running the following command: docker-compose version This will display the version of Docker Compose that is currently installed on your system. If you need to upgrade Docker Compose to a newer version, you can follow the installation instructions in the Docker documentation: https://docs.docker.com/compose/install/ Once you have a recent version of docker-compose, run the commands below in your Auto-GPT folder. Build the image. If you have pulled the image from Docker Hub, skip this step. docker-compose build auto-gpt Run Auto-GPT docker-compose run --rm auto-gpt By default, this will also start and attach a Redis memory backend. If you do not want this, comment or remove the depends: - redis and redis: sections from docker-compose.yml . For related settings, see Memory > Redis setup . You can pass extra arguments, e.g. running with --gpt3only and --continuous : docker-compose run --rm auto-gpt --gpt3only --continuous If you dare, you can also build and run it with \"vanilla\" docker commands: docker build -t auto-gpt . docker run -it --env-file = .env -v $PWD :/app auto-gpt docker run -it --env-file = .env -v $PWD :/app --rm auto-gpt --gpt3only --continuous","title":"Run with Docker"},{"location":"setup/#run-with-dev-container","text":"Install the Remote - Containers extension in VS Code. Open command palette with F1 and type Dev Containers: Open Folder in Container . Run ./run.sh .","title":"Run with Dev Container"},{"location":"setup/#run-without-docker","text":"Simply run the startup script in your terminal. This will install any necessary Python packages and launch Auto-GPT. On Linux/MacOS: ./run.sh On Windows: . \\r un.bat If this gives errors, make sure you have a compatible Python version installed. See also the requirements .","title":"Run without Docker"},{"location":"testing/","text":"Running tests To run all tests, use the following command: pytest If pytest is not found: python -m pytest Running specific test suites To run without integration tests: pytest --without-integration To run without slow integration tests: pytest --without-slow-integration To run tests and see coverage: pytest --cov = autogpt --without-integration --without-slow-integration Running the linter This project uses flake8 for linting. We currently use the following rules: E303,W293,W291,W292,E305,E231,E302 . See the flake8 rules for more information. To run the linter: flake8 . Or: python -m flake8 .","title":"Running tests"},{"location":"testing/#running-tests","text":"To run all tests, use the following command: pytest If pytest is not found: python -m pytest","title":"Running tests"},{"location":"testing/#running-specific-test-suites","text":"To run without integration tests: pytest --without-integration To run without slow integration tests: pytest --without-slow-integration To run tests and see coverage: pytest --cov = autogpt --without-integration --without-slow-integration","title":"Running specific test suites"},{"location":"testing/#running-the-linter","text":"This project uses flake8 for linting. We currently use the following rules: E303,W293,W291,W292,E305,E231,E302 . See the flake8 rules for more information. To run the linter: flake8 . Or: python -m flake8 .","title":"Running the linter"},{"location":"usage/","text":"Usage Command Line Arguments Running with --help lists all the possible command line arguments you can pass: ./run.sh --help # on Linux / macOS . \\r un.bat --help # on Windows Info For use with Docker, replace the script in the examples with docker-compose run --rm auto-gpt : docker-compose run --rm auto-gpt --help docker-compose run --rm auto-gpt --ai-settings <filename> Note Replace anything in angled brackets (<>) to a value you want to specify Here are some common arguments you can use when running Auto-GPT: Run Auto-GPT with a different AI Settings file ./run.sh --ai-settings <filename> Specify a memory backend ./run.sh --use-memory <memory-backend> Note There are shorthands for some of these flags, for example -m for --use-memory . Use ./run.sh --help for more information. Speak Mode Enter this command to use TTS (Text-to-Speech) for Auto-GPT ./run.sh --speak \ud83d\udc80 Continuous Mode \u26a0\ufe0f Run the AI without user authorization, 100% automated. Continuous mode is NOT recommended. It is potentially dangerous and may cause your AI to run forever or carry out actions you would not usually authorize. Use at your own risk. ./run.sh --continuous To exit the program, press Ctrl + C \u267b\ufe0f Self-Feedback Mode \u26a0\ufe0f Running Self-Feedback will INCREASE token use and thus cost more. This feature enables the agent to provide self-feedback by verifying its own actions and checking if they align with its current goals. If not, it will provide better feedback for the next loop. To enable this feature for the current loop, input S into the input field. GPT-3.5 ONLY Mode If you don't have access to GPT-4, this mode allows you to use Auto-GPT! ./run.sh --gpt3only You can achieve the same by setting SMART_LLM_MODEL in .env to gpt-3.5-turbo . GPT-4 ONLY Mode If you have access to GPT-4, this mode allows you to use Auto-GPT solely with GPT-4. This may give your bot increased intelligence. ./run.sh --gpt4only Warning Since GPT-4 is more expensive to use, running Auto-GPT in GPT-4-only mode will increase your API costs. Logs Activity and error logs are located in the ./output/logs To print out debug logs: ./run.sh --debug Disabling Command Categories If you want to selectively disable some command groups, you can use the DISABLED_COMMAND_CATEGORIES config in your .env . You can find the list of categories in your .env.template For example, to disable coding related features, set it to the value below: DISABLED_COMMAND_CATEGORIES = autogpt.commands.analyze_code,autogpt.commands.execute_code,autogpt.commands.git_operations,autogpt.commands.improve_code,autogpt.commands.write_tests","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#command-line-arguments","text":"Running with --help lists all the possible command line arguments you can pass: ./run.sh --help # on Linux / macOS . \\r un.bat --help # on Windows Info For use with Docker, replace the script in the examples with docker-compose run --rm auto-gpt : docker-compose run --rm auto-gpt --help docker-compose run --rm auto-gpt --ai-settings <filename> Note Replace anything in angled brackets (<>) to a value you want to specify Here are some common arguments you can use when running Auto-GPT: Run Auto-GPT with a different AI Settings file ./run.sh --ai-settings <filename> Specify a memory backend ./run.sh --use-memory <memory-backend> Note There are shorthands for some of these flags, for example -m for --use-memory . Use ./run.sh --help for more information.","title":"Command Line Arguments"},{"location":"usage/#speak-mode","text":"Enter this command to use TTS (Text-to-Speech) for Auto-GPT ./run.sh --speak","title":"Speak Mode"},{"location":"usage/#continuous-mode","text":"Run the AI without user authorization, 100% automated. Continuous mode is NOT recommended. It is potentially dangerous and may cause your AI to run forever or carry out actions you would not usually authorize. Use at your own risk. ./run.sh --continuous To exit the program, press Ctrl + C","title":"\ud83d\udc80 Continuous Mode \u26a0\ufe0f"},{"location":"usage/#self-feedback-mode","text":"Running Self-Feedback will INCREASE token use and thus cost more. This feature enables the agent to provide self-feedback by verifying its own actions and checking if they align with its current goals. If not, it will provide better feedback for the next loop. To enable this feature for the current loop, input S into the input field.","title":"\u267b\ufe0f Self-Feedback Mode \u26a0\ufe0f"},{"location":"usage/#gpt-35-only-mode","text":"If you don't have access to GPT-4, this mode allows you to use Auto-GPT! ./run.sh --gpt3only You can achieve the same by setting SMART_LLM_MODEL in .env to gpt-3.5-turbo .","title":"GPT-3.5 ONLY Mode"},{"location":"usage/#gpt-4-only-mode","text":"If you have access to GPT-4, this mode allows you to use Auto-GPT solely with GPT-4. This may give your bot increased intelligence. ./run.sh --gpt4only Warning Since GPT-4 is more expensive to use, running Auto-GPT in GPT-4-only mode will increase your API costs.","title":"GPT-4 ONLY Mode"},{"location":"usage/#logs","text":"Activity and error logs are located in the ./output/logs To print out debug logs: ./run.sh --debug","title":"Logs"},{"location":"usage/#disabling-command-categories","text":"If you want to selectively disable some command groups, you can use the DISABLED_COMMAND_CATEGORIES config in your .env . You can find the list of categories in your .env.template For example, to disable coding related features, set it to the value below: DISABLED_COMMAND_CATEGORIES = autogpt.commands.analyze_code,autogpt.commands.execute_code,autogpt.commands.git_operations,autogpt.commands.improve_code,autogpt.commands.write_tests","title":"Disabling Command Categories"},{"location":"challenges/beat/","text":"Beat a Challenge If you have a solution or idea to tackle an existing challenge, you can contribute by working on it and submitting your solution. Here's how to get started: Guidelines for Beating a Challenge Choose a challenge : Browse the List of Challenges and choose one that interests you or aligns with your expertise. Understand the problem : Make sure you thoroughly understand the problem at hand, its scope, and the desired outcome. Develop a solution : Work on creating a solution for the challenge. This may/","title":"Beat a Challenge"},{"location":"challenges/beat/#beat-a-challenge","text":"If you have a solution or idea to tackle an existing challenge, you can contribute by working on it and submitting your solution. Here's how to get started:","title":"Beat a Challenge"},{"location":"challenges/beat/#guidelines-for-beating-a-challenge","text":"Choose a challenge : Browse the List of Challenges and choose one that interests you or aligns with your expertise. Understand the problem : Make sure you thoroughly understand the problem at hand, its scope, and the desired outcome. Develop a solution : Work on creating a solution for the challenge. This may/","title":"Guidelines for Beating a Challenge"},{"location":"challenges/building_challenges/","text":"Creating Challenges for AutoGPT \ud83c\udff9 We're on the hunt for talented Challenge Creators! \ud83c\udfaf Join us in shaping the future of Auto-GPT by designing challenges that test its limits. Your input will be invaluable in guiding our progress and ensuring that we're on the right track. We're seeking individuals with a diverse skill set, including: \ud83c\udfa8 UX Design: Your expertise will enhance the user experience for those attempting to conquer our challenges. With your help, we'll develop a dedicated section in our wiki, and potentially even launch a standalone website. \ud83d\udcbb Coding Skills: Proficiency in Python, pytest, and VCR (a library that records OpenAI calls and stores them) will be essential for creating engaging and robust challenges. \u2699\ufe0f DevOps Skills: Experience with CI pipelines in GitHub and possibly Google Cloud Platform will be instrumental in streamlining our operations. Are you ready to play a pivotal role in Auto-GPT's journey? Apply now to become a Challenge Creator by opening a PR! \ud83d\ude80 Getting Started Clone the original AutoGPT repo and checkout to master branch The challenges are not written using a specific framework. They try to be very agnostic The challenges are acting like a user that wants something done: INPUT: - User desire - Files, other inputs Output => Artifact (files, image, code, etc, etc...) Defining your Agent Go to https://github.com/Significant-Gravitas/Auto-GPT/blob/master/tests/integration/agent_factory.py Create your agent fixture. def kubernetes_agent ( agent_test_config , memory_local_cache , workspace : Workspace ): # Please choose the commands your agent will need to beat the challenges, the full list is available in the main.py # (we 're working on a better way to design this, for now you have to look at main.py) command_registry = CommandRegistry () command_registry . import_commands ( \"autogpt.commands.file_operations\" ) command_registry . import_commands ( \"autogpt.app\" ) # Define all the settings of our challenged agent ai_config = AIConfig ( ai_name = \"Kubernetes\" , ai_role = \"an autonomous agent that specializes in creating Kubernetes deployment templates.\" , ai_goals = [ \"Write a simple kubernetes deployment file and save it as a kube.yaml.\" , ], ) ai_config . command_registry = command_registry system_prompt = ai_config . construct_full_prompt () Config () . set_continuous_mode ( False ) agent = Agent ( # We also give the AI a name ai_name = \"Kubernetes-Demo\" , memory = memory_local_cache , full_message_history = [], command_registry = command_registry , config = ai_config , next_action_count = 0 , system_prompt = system_prompt , triggering_prompt = DEFAULT_TRIGGERING_PROMPT , workspace_directory = workspace . root , ) return agent Creating your challenge Go to tests/integration/challenges and create a file that is called test_your_test_description.py and add it to the appropriate folder. If no category exists you can create a new one. Your test could look something like this import contextlib from functools import wraps from typing import Generator import pytest import yaml from autogpt.commands.file_operations import read_file , write_to_file from tests.integration.agent_utils import run_interaction_loop from tests.integration.challenges.utils import run_multiple_times from tests.utils import requires_api_key def input_generator ( input_sequence : list ) -> Generator [ str , None , None ]: \"\"\" Creates a generator that yields input strings from the given sequence. :param input_sequence: A list of input strings. :return: A generator that yields input strings. \"\"\" yield from input_sequence @pytest . mark . skip ( \"This challenge hasn't been beaten yet.\" ) @pytest . mark . vcr @requires_api_key ( \"OPENAI_API_KEY\" ) @run_multiple_times ( 3 ) def test_information_retrieval_challenge_a ( kubernetes_agent , monkeypatch ) -> None : \"\"\" Test the challenge_a function in a given agent by mocking user inputs and checking the output file content. :param get_company_revenue_agent: The agent to test. :param monkeypatch: pytest's monkeypatch utility for modifying builtins. \"\"\" input_sequence = [ \"s\" , \"s\" , \"s\" , \"s\" , \"s\" , \"EXIT\" ] gen = input_generator ( input_sequence ) monkeypatch . setattr ( \"builtins.input\" , lambda _ : next ( gen )) with contextlib . suppress ( SystemExit ): run_interaction_loop ( kubernetes_agent , None ) # here we load the output file file_path = str ( kubernetes_agent . workspace . get_path ( \"kube.yaml\" )) content = read_file ( file_path ) # then we check if it's including keywords from the kubernetes deployment config for word in [ \"apiVersion\" , \"kind\" , \"metadata\" , \"spec\" ]: assert word in content , f \"Expected the file to contain { word } \" content = yaml . safe_load ( content ) for word in [ \"Service\" , \"Deployment\" , \"Pod\" ]: assert word in content [ \"kind\" ], f \"Expected the file to contain { word } \"","title":"Creating Challenges for AutoGPT"},{"location":"challenges/building_challenges/#creating-challenges-for-autogpt","text":"\ud83c\udff9 We're on the hunt for talented Challenge Creators! \ud83c\udfaf Join us in shaping the future of Auto-GPT by designing challenges that test its limits. Your input will be invaluable in guiding our progress and ensuring that we're on the right track. We're seeking individuals with a diverse skill set, including: \ud83c\udfa8 UX Design: Your expertise will enhance the user experience for those attempting to conquer our challenges. With your help, we'll develop a dedicated section in our wiki, and potentially even launch a standalone website. \ud83d\udcbb Coding Skills: Proficiency in Python, pytest, and VCR (a library that records OpenAI calls and stores them) will be essential for creating engaging and robust challenges. \u2699\ufe0f DevOps Skills: Experience with CI pipelines in GitHub and possibly Google Cloud Platform will be instrumental in streamlining our operations. Are you ready to play a pivotal role in Auto-GPT's journey? Apply now to become a Challenge Creator by opening a PR! \ud83d\ude80","title":"Creating Challenges for AutoGPT"},{"location":"challenges/building_challenges/#getting-started","text":"Clone the original AutoGPT repo and checkout to master branch The challenges are not written using a specific framework. They try to be very agnostic The challenges are acting like a user that wants something done: INPUT: - User desire - Files, other inputs Output => Artifact (files, image, code, etc, etc...)","title":"Getting Started"},{"location":"challenges/building_challenges/#defining-your-agent","text":"Go to https://github.com/Significant-Gravitas/Auto-GPT/blob/master/tests/integration/agent_factory.py Create your agent fixture. def kubernetes_agent ( agent_test_config , memory_local_cache , workspace : Workspace ): # Please choose the commands your agent will need to beat the challenges, the full list is available in the main.py # (we 're working on a better way to design this, for now you have to look at main.py) command_registry = CommandRegistry () command_registry . import_commands ( \"autogpt.commands.file_operations\" ) command_registry . import_commands ( \"autogpt.app\" ) # Define all the settings of our challenged agent ai_config = AIConfig ( ai_name = \"Kubernetes\" , ai_role = \"an autonomous agent that specializes in creating Kubernetes deployment templates.\" , ai_goals = [ \"Write a simple kubernetes deployment file and save it as a kube.yaml.\" , ], ) ai_config . command_registry = command_registry system_prompt = ai_config . construct_full_prompt () Config () . set_continuous_mode ( False ) agent = Agent ( # We also give the AI a name ai_name = \"Kubernetes-Demo\" , memory = memory_local_cache , full_message_history = [], command_registry = command_registry , config = ai_config , next_action_count = 0 , system_prompt = system_prompt , triggering_prompt = DEFAULT_TRIGGERING_PROMPT , workspace_directory = workspace . root , ) return agent","title":"Defining your Agent"},{"location":"challenges/building_challenges/#creating-your-challenge","text":"Go to tests/integration/challenges and create a file that is called test_your_test_description.py and add it to the appropriate folder. If no category exists you can create a new one. Your test could look something like this import contextlib from functools import wraps from typing import Generator import pytest import yaml from autogpt.commands.file_operations import read_file , write_to_file from tests.integration.agent_utils import run_interaction_loop from tests.integration.challenges.utils import run_multiple_times from tests.utils import requires_api_key def input_generator ( input_sequence : list ) -> Generator [ str , None , None ]: \"\"\" Creates a generator that yields input strings from the given sequence. :param input_sequence: A list of input strings. :return: A generator that yields input strings. \"\"\" yield from input_sequence @pytest . mark . skip ( \"This challenge hasn't been beaten yet.\" ) @pytest . mark . vcr @requires_api_key ( \"OPENAI_API_KEY\" ) @run_multiple_times ( 3 ) def test_information_retrieval_challenge_a ( kubernetes_agent , monkeypatch ) -> None : \"\"\" Test the challenge_a function in a given agent by mocking user inputs and checking the output file content. :param get_company_revenue_agent: The agent to test. :param monkeypatch: pytest's monkeypatch utility for modifying builtins. \"\"\" input_sequence = [ \"s\" , \"s\" , \"s\" , \"s\" , \"s\" , \"EXIT\" ] gen = input_generator ( input_sequence ) monkeypatch . setattr ( \"builtins.input\" , lambda _ : next ( gen )) with contextlib . suppress ( SystemExit ): run_interaction_loop ( kubernetes_agent , None ) # here we load the output file file_path = str ( kubernetes_agent . workspace . get_path ( \"kube.yaml\" )) content = read_file ( file_path ) # then we check if it's including keywords from the kubernetes deployment config for word in [ \"apiVersion\" , \"kind\" , \"metadata\" , \"spec\" ]: assert word in content , f \"Expected the file to contain { word } \" content = yaml . safe_load ( content ) for word in [ \"Service\" , \"Deployment\" , \"Pod\" ]: assert word in content [ \"kind\" ], f \"Expected the file to contain { word } \"","title":"Creating your challenge"},{"location":"challenges/challenge_template/","text":"Challenge Title Description Provide a clear and concise description of the challenge. Include any relevant examples or files to illustrate the problem. Input If the challenge involves specific input files, describe them here. Provide the file names and their contents, if necessary. Use triple backticks (```) to format the content as a code block. For example: instructions_1.txt The current task_id is 4563.\\n[NOISE intended to confuse the agent] Read the file instructions_2.txt using the read_file command. Scope Define the scope of the challenge, including any relevant constraints, requirements, or limitations. Success Evaluation Explain how success will be measured or evaluated for the challenge. This helps others understand what the desired outcome is and how to work towards it.","title":"Challenge Title"},{"location":"challenges/challenge_template/#challenge-title","text":"","title":"Challenge Title"},{"location":"challenges/challenge_template/#description","text":"Provide a clear and concise description of the challenge. Include any relevant examples or files to illustrate the problem.","title":"Description"},{"location":"challenges/challenge_template/#input","text":"If the challenge involves specific input files, describe them here. Provide the file names and their contents, if necessary. Use triple backticks (```) to format the content as a code block. For example: instructions_1.txt The current task_id is 4563.\\n[NOISE intended to confuse the agent] Read the file instructions_2.txt using the read_file command.","title":"Input"},{"location":"challenges/challenge_template/#scope","text":"Define the scope of the challenge, including any relevant constraints, requirements, or limitations.","title":"Scope"},{"location":"challenges/challenge_template/#success-evaluation","text":"Explain how success will be measured or evaluated for the challenge. This helps others understand what the desired outcome is and how to work towards it.","title":"Success Evaluation"},{"location":"challenges/introduction/","text":"introduction.md Introduction to Challenges Welcome to the Auto-GPT Challenges page! This is a space where we encourage community members to collaborate and contribute towards improving Auto-GPT by identifying and solving challenges that Auto-GPT is not yet able to achieve. What are challenges? Challenges are tasks or problems that Auto-GPT has difficulty solving or has not yet been able to accomplish. These may include improving specific functionalities, enhancing the model's understanding of specific domains, or even developing new features that the current version of Auto-GPT lacks. Why are challenges important? Addressing challenges helps us improve Auto-GPT's performance, usability, and versatility. By working together to tackle these challenges, we can create a more powerful and efficient tool for everyone. It also allows the community to actively contribute to the project, making it a true open-source effort. How can you participate? There are two main ways to get involved with challenges: Submit a Challenge : If you have identified a task that Auto-GPT struggles with, you can submit it as a challenge. This allows others to see the issue and collaborate on finding a solution. Beat a Challenge : If you have a solution or idea to tackle an existing challenge, you can contribute by working on the challenge and submitting your solution. To learn more about submitting and beating challenges, please visit the List of Challenges , Submit a Challenge , and Beat a Challenge pages. We look forward to your contributions and the exciting solutions that the community will develop together to make Auto-GPT even better!","title":"Introduction"},{"location":"challenges/introduction/#introduction-to-challenges","text":"Welcome to the Auto-GPT Challenges page! This is a space where we encourage community members to collaborate and contribute towards improving Auto-GPT by identifying and solving challenges that Auto-GPT is not yet able to achieve.","title":"Introduction to Challenges"},{"location":"challenges/introduction/#what-are-challenges","text":"Challenges are tasks or problems that Auto-GPT has difficulty solving or has not yet been able to accomplish. These may include improving specific functionalities, enhancing the model's understanding of specific domains, or even developing new features that the current version of Auto-GPT lacks.","title":"What are challenges?"},{"location":"challenges/introduction/#why-are-challenges-important","text":"Addressing challenges helps us improve Auto-GPT's performance, usability, and versatility. By working together to tackle these challenges, we can create a more powerful and efficient tool for everyone. It also allows the community to actively contribute to the project, making it a true open-source effort.","title":"Why are challenges important?"},{"location":"challenges/introduction/#how-can-you-participate","text":"There are two main ways to get involved with challenges: Submit a Challenge : If you have identified a task that Auto-GPT struggles with, you can submit it as a challenge. This allows others to see the issue and collaborate on finding a solution. Beat a Challenge : If you have a solution or idea to tackle an existing challenge, you can contribute by working on the challenge and submitting your solution. To learn more about submitting and beating challenges, please visit the List of Challenges , Submit a Challenge , and Beat a Challenge pages. We look forward to your contributions and the exciting solutions that the community will develop together to make Auto-GPT even better!","title":"How can you participate?"},{"location":"challenges/list/","text":"List of Challenges This page contains a curated list of challenges that Auto-GPT currently faces. If you think you have a solution or idea to tackle any of these challenges, feel free to dive in and start working on them! New challenges can also be submitted by following the guidelines on the Submit a Challenge page. Memory Challenges: List of Challenges","title":"List of Challenges"},{"location":"challenges/list/#list-of-challenges","text":"This page contains a curated list of challenges that Auto-GPT currently faces. If you think you have a solution or idea to tackle any of these challenges, feel free to dive in and start working on them! New challenges can also be submitted by following the guidelines on the Submit a Challenge page. Memory Challenges: List of Challenges","title":"List of Challenges"},{"location":"challenges/submit/","text":"Submit a Challenge If you have identified a task or problem that Auto-GPT struggles with, you can submit it as a challenge for the community to tackle. Here's how you can submit a new challenge: How to Submit a Challenge Create a new .md file in the challenges directory in the Auto-GPT GitHub repository. Make sure to pick the right category. Name the file with a descriptive title for the challenge, using hyphens instead of spaces (e.g., improve-context-understanding.md ). In the file, follow the challenge_template.md to describe the problem, define the scope, and evaluate success. Commit the file and create a pull request. Once submitted, the community can review and discuss the challenge. If deemed appropriate, it will be added to the List of Challenges . If you're looking to contribute by working on an existing challenge, check out Beat a Challenge for guidelines on how to get started.","title":"Submit a Challenge"},{"location":"challenges/submit/#submit-a-challenge","text":"If you have identified a task or problem that Auto-GPT struggles with, you can submit it as a challenge for the community to tackle. Here's how you can submit a new challenge:","title":"Submit a Challenge"},{"location":"challenges/submit/#how-to-submit-a-challenge","text":"Create a new .md file in the challenges directory in the Auto-GPT GitHub repository. Make sure to pick the right category. Name the file with a descriptive title for the challenge, using hyphens instead of spaces (e.g., improve-context-understanding.md ). In the file, follow the challenge_template.md to describe the problem, define the scope, and evaluate success. Commit the file and create a pull request. Once submitted, the community can review and discuss the challenge. If deemed appropriate, it will be added to the List of Challenges . If you're looking to contribute by working on an existing challenge, check out Beat a Challenge for guidelines on how to get started.","title":"How to Submit a Challenge"},{"location":"challenges/information_retrieval/challenge_a/","text":"Information Retrieval Challenge A Status : Current level to beat: level 1 Command to try : pytest -s tests/integration/challenges/information_retrieval/test_information_retrieval_challenge_a.py Description The agent's goal is to find the revenue of Tesla in 2022. It should write the result in a file called output.txt. The agent should be able to beat this test consistently (this is the hardest part). Objective The objective of this challenge is to test the agent's ability to retrieve information in a consistent way.","title":"Information Retrieval Challenge A"},{"location":"challenges/information_retrieval/challenge_a/#information-retrieval-challenge-a","text":"Status : Current level to beat: level 1 Command to try : pytest -s tests/integration/challenges/information_retrieval/test_information_retrieval_challenge_a.py","title":"Information Retrieval Challenge A"},{"location":"challenges/information_retrieval/challenge_a/#description","text":"The agent's goal is to find the revenue of Tesla in 2022. It should write the result in a file called output.txt. The agent should be able to beat this test consistently (this is the hardest part).","title":"Description"},{"location":"challenges/information_retrieval/challenge_a/#objective","text":"The objective of this challenge is to test the agent's ability to retrieve information in a consistent way.","title":"Objective"},{"location":"challenges/information_retrieval/introduction/","text":"Information Retrieval Information retrieval challenges are designed to evaluate the proficiency of an AI agent, such as Auto-GPT, in searching, extracting, and presenting relevant information from a vast array of sources. These challenges often encompass tasks such as interpreting user queries, browsing the web, and filtering through unstructured data.","title":"Introduction"},{"location":"challenges/information_retrieval/introduction/#information-retrieval","text":"Information retrieval challenges are designed to evaluate the proficiency of an AI agent, such as Auto-GPT, in searching, extracting, and presenting relevant information from a vast array of sources. These challenges often encompass tasks such as interpreting user queries, browsing the web, and filtering through unstructured data.","title":"Information Retrieval"},{"location":"challenges/memory/challenge_a/","text":"Memory Challenge A Status : Challenge Completed Description The agent, Follow-Instructions-GPT, has the following goals: Use the command read_file to read the instructions_1.txt file. Follow the instructions in the instructions_1.txt file. The challenge involves a series of text files containing instructions. The agent must follow the instructions and keep track of the task ID as it progresses through the files. Files instructions_1.txt The task_id is 1234 Read the file instructions_1.txt instructions_2.txt Read the file instructions_2.txt using the read_file command. ...and so on. instructions_n.txt Write the task_id into the file output.txt. Objective The objective of this challenge is to test the agent's ability to follow instructions and maintain memory of the task Id throughout the process. The agent successfully completed this challenge if it wrote the task id in a file.","title":"Memory Challenge A"},{"location":"challenges/memory/challenge_a/#memory-challenge-a","text":"Status : Challenge Completed","title":"Memory Challenge A"},{"location":"challenges/memory/challenge_a/#description","text":"The agent, Follow-Instructions-GPT, has the following goals: Use the command read_file to read the instructions_1.txt file. Follow the instructions in the instructions_1.txt file. The challenge involves a series of text files containing instructions. The agent must follow the instructions and keep track of the task ID as it progresses through the files.","title":"Description"},{"location":"challenges/memory/challenge_a/#files","text":"instructions_1.txt The task_id is 1234 Read the file instructions_1.txt instructions_2.txt Read the file instructions_2.txt using the read_file command. ...and so on. instructions_n.txt Write the task_id into the file output.txt.","title":"Files"},{"location":"challenges/memory/challenge_a/#objective","text":"The objective of this challenge is to test the agent's ability to follow instructions and maintain memory of the task Id throughout the process. The agent successfully completed this challenge if it wrote the task id in a file.","title":"Objective"},{"location":"challenges/memory/challenge_b/","text":"Memory Challenge B Status : Current level to beat: level 3 Command to try : ` pytest -s tests/integration/challenges/memory/test_memory_challenge_b.py --level=3 Description The agent, Follow-Instructions-GPT, has the following goals: Use the command read_file to read the instructions_1.txt file. Follow the instructions in the instructions_1.txt file. The challenge involves a series of text files containing instructions and task IDs. The agent must follow the instructions and keep track of the task IDs as it progresses through the files. Files instructions_1.txt The current task_id is 4563.\\n[NOISE intended to confuse the agent] Read the file instructions_2.txt using the read_file command. instructions_2.txt The current task_id is 6182.\\n[NOISE intended to confuse the agent] Read the file instructions_3.txt using the read_file command. ...and so on. instructions_n.txt The current task_id is 8912. Write all the task_ids into the file output.txt. The file has not been created yet. After that, use the task_complete command. Objective The objective of this challenge is to test the agent's ability to follow instructions and maintain memory of the task IDs throughout the process. The agent successfully completed this challenge if it wrote the task ids in a file.","title":"Memory Challenge B"},{"location":"challenges/memory/challenge_b/#memory-challenge-b","text":"Status : Current level to beat: level 3 Command to try : ` pytest -s tests/integration/challenges/memory/test_memory_challenge_b.py --level=3","title":"Memory Challenge B"},{"location":"challenges/memory/challenge_b/#description","text":"The agent, Follow-Instructions-GPT, has the following goals: Use the command read_file to read the instructions_1.txt file. Follow the instructions in the instructions_1.txt file. The challenge involves a series of text files containing instructions and task IDs. The agent must follow the instructions and keep track of the task IDs as it progresses through the files.","title":"Description"},{"location":"challenges/memory/challenge_b/#files","text":"instructions_1.txt The current task_id is 4563.\\n[NOISE intended to confuse the agent] Read the file instructions_2.txt using the read_file command. instructions_2.txt The current task_id is 6182.\\n[NOISE intended to confuse the agent] Read the file instructions_3.txt using the read_file command. ...and so on. instructions_n.txt The current task_id is 8912. Write all the task_ids into the file output.txt. The file has not been created yet. After that, use the task_complete command.","title":"Files"},{"location":"challenges/memory/challenge_b/#objective","text":"The objective of this challenge is to test the agent's ability to follow instructions and maintain memory of the task IDs throughout the process. The agent successfully completed this challenge if it wrote the task ids in a file.","title":"Objective"},{"location":"challenges/memory/challenge_c/","text":"Memory Challenge C Status : Current level to beat: level 1 Command to try : ` pytest -s tests/integration/challenges/memory/test_memory_challenge_c.py --level=2 Description The agent, Follow-Instructions-GPT, has the following goals: Use the command read_file to read the instructions_1.txt file. Follow the instructions in the instructions_1.txt file. The challenge involves a series of text files containing instructions and silly phrases. The agent must follow the instructions and keep track of the task IDs as it progresses through the files. Files instructions_1.txt The current phrase is \"The purple elephant danced on a rainbow while eating a taco.\".\\n[NOISE intended to confuse the agent] Read the file instructions_2.txt using the read_file command. instructions_2.txt The current phrase is \"The sneaky toaster stole my socks and ran away to Hawaii.\".\\n[NOISE intended to confuse the agent] Read the file instructions_3.txt using the read_file command. ...and so on. instructions_n.txt The current phrase is \"My pet rock sings better than Beyonc\u00e9 on Tuesdays.\" Write all the phrases into the file output.txt. The file has not been created yet. After that, use the task_complete command. Objective The objective of this challenge is to test the agent's ability to follow instructions and maintain memory of the task IDs throughout the process. The agent successfully completed this challenge if it wrote the phrases in a file. This is presumably harder than task ids as the phrases are longer and more likely to be compressed as the agent does more work.","title":"Memory Challenge C"},{"location":"challenges/memory/challenge_c/#memory-challenge-c","text":"Status : Current level to beat: level 1 Command to try : ` pytest -s tests/integration/challenges/memory/test_memory_challenge_c.py --level=2","title":"Memory Challenge C"},{"location":"challenges/memory/challenge_c/#description","text":"The agent, Follow-Instructions-GPT, has the following goals: Use the command read_file to read the instructions_1.txt file. Follow the instructions in the instructions_1.txt file. The challenge involves a series of text files containing instructions and silly phrases. The agent must follow the instructions and keep track of the task IDs as it progresses through the files.","title":"Description"},{"location":"challenges/memory/challenge_c/#files","text":"instructions_1.txt The current phrase is \"The purple elephant danced on a rainbow while eating a taco.\".\\n[NOISE intended to confuse the agent] Read the file instructions_2.txt using the read_file command. instructions_2.txt The current phrase is \"The sneaky toaster stole my socks and ran away to Hawaii.\".\\n[NOISE intended to confuse the agent] Read the file instructions_3.txt using the read_file command. ...and so on. instructions_n.txt The current phrase is \"My pet rock sings better than Beyonc\u00e9 on Tuesdays.\" Write all the phrases into the file output.txt. The file has not been created yet. After that, use the task_complete command.","title":"Files"},{"location":"challenges/memory/challenge_c/#objective","text":"The objective of this challenge is to test the agent's ability to follow instructions and maintain memory of the task IDs throughout the process. The agent successfully completed this challenge if it wrote the phrases in a file. This is presumably harder than task ids as the phrases are longer and more likely to be compressed as the agent does more work.","title":"Objective"},{"location":"challenges/memory/introduction/","text":"Memory Challenges Memory challenges are designed to test the ability of an AI agent, like Auto-GPT, to remember and use information throughout a series of tasks. These challenges often involve following instructions, processing text files, and keeping track of important data. The goal of memory challenges is to improve an agent's performance in tasks that require remembering and using information over time. By addressing these challenges, we can enhance Auto-GPT's capabilities and make it more useful in real-world applications.","title":"Introduction"},{"location":"challenges/memory/introduction/#memory-challenges","text":"Memory challenges are designed to test the ability of an AI agent, like Auto-GPT, to remember and use information throughout a series of tasks. These challenges often involve following instructions, processing text files, and keeping track of important data. The goal of memory challenges is to improve an agent's performance in tasks that require remembering and using information over time. By addressing these challenges, we can enhance Auto-GPT's capabilities and make it more useful in real-world applications.","title":"Memory Challenges"},{"location":"configuration/imagegen/","text":"\ud83d\uddbc Image Generation configuration Config variable Values IMAGE_PROVIDER dalle huggingface sdwebui default: dalle DALL-e In .env , make sure IMAGE_PROVIDER is commented (or set to dalle ): # IMAGE_PROVIDER=dalle # this is the default Further optional configuration: Config variable Values IMAGE_SIZE 256 512 1024 default: 256 Hugging Face To use text-to-image models from Hugging Face, you need a Hugging Face API token. Link to the appropriate settings page: Hugging Face > Settings > Tokens Once you have an API token, uncomment and adjust these variables in your .env : IMAGE_PROVIDER = huggingface HUGGINGFACE_API_TOKEN = your-huggingface-api-token Further optional configuration: Config variable Values HUGGINGFACE_IMAGE_MODEL see available models default: CompVis/stable-diffusion-v1-4 Stable Diffusion WebUI It is possible to use your own self-hosted Stable Diffusion WebUI with Auto-GPT: IMAGE_PROVIDER = sdwebui Note Make sure you are running WebUI with --api enabled. Further optional configuration: Config variable Values SD_WEBUI_URL URL to your WebUI default: http://127.0.0.1:7860 SD_WEBUI_AUTH {username}:{password} Note: do not copy the braces! Selenium sudo Xvfb :10 -ac -screen 0 1024x768x24 & DISPLAY = :10 <YOUR_CLIENT>","title":"Image Generation"},{"location":"configuration/imagegen/#image-generation-configuration","text":"Config variable Values IMAGE_PROVIDER dalle huggingface sdwebui default: dalle","title":"\ud83d\uddbc Image Generation configuration"},{"location":"configuration/imagegen/#dall-e","text":"In .env , make sure IMAGE_PROVIDER is commented (or set to dalle ): # IMAGE_PROVIDER=dalle # this is the default Further optional configuration: Config variable Values IMAGE_SIZE 256 512 1024 default: 256","title":"DALL-e"},{"location":"configuration/imagegen/#hugging-face","text":"To use text-to-image models from Hugging Face, you need a Hugging Face API token. Link to the appropriate settings page: Hugging Face > Settings > Tokens Once you have an API token, uncomment and adjust these variables in your .env : IMAGE_PROVIDER = huggingface HUGGINGFACE_API_TOKEN = your-huggingface-api-token Further optional configuration: Config variable Values HUGGINGFACE_IMAGE_MODEL see available models default: CompVis/stable-diffusion-v1-4","title":"Hugging Face"},{"location":"configuration/imagegen/#stable-diffusion-webui","text":"It is possible to use your own self-hosted Stable Diffusion WebUI with Auto-GPT: IMAGE_PROVIDER = sdwebui Note Make sure you are running WebUI with --api enabled. Further optional configuration: Config variable Values SD_WEBUI_URL URL to your WebUI default: http://127.0.0.1:7860 SD_WEBUI_AUTH {username}:{password} Note: do not copy the braces!","title":"Stable Diffusion WebUI"},{"location":"configuration/imagegen/#selenium","text":"sudo Xvfb :10 -ac -screen 0 1024x768x24 & DISPLAY = :10 <YOUR_CLIENT>","title":"Selenium"},{"location":"configuration/memory/","text":"Setting Your Cache Type By default, Auto-GPT set up with Docker Compose will use Redis as its memory backend. Otherwise, the default is LocalCache (which stores memory in a JSON file). To switch to a different backend, change the MEMORY_BACKEND in .env to the value that you want: local uses a local JSON cache file pinecone uses the Pinecone.io account you configured in your ENV settings redis will use the redis cache that you configured milvus will use the milvus cache that you configured weaviate will use the weaviate cache that you configured Memory Backend Setup Links to memory backends Pinecone Milvus \u2013 self-hosted , or managed with Zilliz Cloud Redis Weaviate Redis Setup Important If you have set up Auto-GPT using Docker Compose, then Redis is included, no further setup needed. Caution This setup is not intended to be publicly accessible and lacks security measures. Avoid exposing Redis to the internet without a password or at all! Launch Redis container docker run -d --name redis-stack-server -p 6379 :6379 redis/redis-stack-server:latest Set the following settings in .env MEMORY_BACKEND = redis REDIS_HOST = localhost REDIS_PORT = 6379 REDIS_PASSWORD = <PASSWORD> Replace <PASSWORD> by your password, omitting the angled brackets (<>). Optional configuration: WIPE_REDIS_ON_START=False to persist memory stored in Redis between runs. MEMORY_INDEX=<WHATEVER> to specify a name for the memory index in Redis. The default is auto-gpt . Info See redis-stack-server for setting a password and additional configuration. \ud83c\udf32 Pinecone API Key Setup Pinecone lets you store vast amounts of vector-based memory, allowing the agent to load only relevant memories at any given time. Go to pinecone and make an account if you don't already have one. Choose the Starter plan to avoid being charged. Find your API key and region under the default project in the left sidebar. In the .env file set: PINECONE_API_KEY PINECONE_ENV (example: us-east4-gcp ) MEMORY_BACKEND=pinecone Milvus Setup Milvus is an open-source, highly scalable vector database to store huge amounts of vector-based memory and provide fast relevant search. It can be quickly deployed with docker, or as a cloud service provided by Zilliz Cloud . Deploy your Milvus service, either locally using docker or with a managed Zilliz Cloud database: Install and deploy Milvus locally Set up a managed Zilliz Cloud database Go to Zilliz Cloud and sign up if you don't already have account. In the Databases tab, create a new database. Remember your username and password Wait until the database status is changed to RUNNING. In the Database detail tab of the database you have created, the public cloud endpoint, such as: https://xxx-xxxx.xxxx.xxxx.zillizcloud.com:443 . Run pip3 install pymilvus to install the required client library. Make sure your PyMilvus version and Milvus version are compatible to avoid issues. See also the PyMilvus installation instructions . Update .env : MEMORY_BACKEND=milvus One of: MILVUS_ADDR=host:ip (for local instance) MILVUS_ADDR=https://xxx-xxxx.xxxx.xxxx.zillizcloud.com:443 (for Zilliz Cloud) The following settings are optional : MILVUS_USERNAME='username-of-your-milvus-instance' MILVUS_PASSWORD='password-of-your-milvus-instance' MILVUS_SECURE=True to use a secure connection. Only use if your Milvus instance has TLS enabled. Note: setting MILVUS_ADDR to a https:// URL will override this setting. MILVUS_COLLECTION to change the collection name to use in Milvus. Defaults to autogpt . Weaviate Setup Weaviate is an open-source vector database. It allows to store data objects and vector embeddings from ML-models and scales seamlessly to billion of data objects. To set up a Weaviate database, check out their Quickstart Tutorial . Although still experimental, Embedded Weaviate is supported which allows the Auto-GPT process itself to start a Weaviate instance. To enable it, set USE_WEAVIATE_EMBEDDED to True and make sure you pip install \"weaviate-client>=3.15.4\" . Install the Weaviate client Install the Weaviate client before usage. $ pip install weaviate-client Setting up environment variables In your .env file set the following: MEMORY_BACKEND = weaviate WEAVIATE_HOST = \"127.0.0.1\" # the IP or domain of the running Weaviate instance WEAVIATE_PORT = \"8080\" WEAVIATE_PROTOCOL = \"http\" WEAVIATE_USERNAME = \"your username\" WEAVIATE_PASSWORD = \"your password\" WEAVIATE_API_KEY = \"your weaviate API key if you have one\" WEAVIATE_EMBEDDED_PATH = \"/home/me/.local/share/weaviate\" # this is optional and indicates where the data should be persisted when running an embedded instance USE_WEAVIATE_EMBEDDED = False # set to True to run Embedded Weaviate MEMORY_INDEX = \"Autogpt\" # name of the index to create for the application View Memory Usage View memory usage by using the --debug flag :) \ud83e\udde0 Memory pre-seeding Memory pre-seeding allows you to ingest files into memory and pre-seed it before running Auto-GPT. $ python data_ingestion.py -h usage: data_ingestion.py [ -h ] ( --file FILE | --dir DIR ) [ --init ] [ --overlap OVERLAP ] [ --max_length MAX_LENGTH ] Ingest a file or a directory with multiple files into memory. Make sure to set your .env before running this script. options: -h, --help show this help message and exit --file FILE The file to ingest. --dir DIR The directory containing the files to ingest. --init Init the memory and wipe its content ( default: False ) --overlap OVERLAP The overlap size between chunks when ingesting files ( default: 200 ) --max_length MAX_LENGTH The max_length of each chunk when ingesting files ( default: 4000 ) # python data_ingestion.py --dir DataFolder --init --overlap 100 --max_length 2000 In the example above, the script initializes the memory, ingests all files within the Auto-Gpt/autogpt/auto_gpt_workspace/DataFolder directory into memory with an overlap between chunks of 100 and a maximum length of each chunk of 2000. Note that you can also use the --file argument to ingest a single file into memory and that data_ingestion.py will only ingest files within the /auto_gpt_workspace directory. The DIR path is relative to the auto_gpt_workspace directory, so python data_ingestion.py --dir . --init will ingest everything in auto_gpt_workspace directory. You can adjust the max_length and overlap parameters to fine-tune the way the documents are presented to the AI when it \"recall\" that memory: Adjusting the overlap value allows the AI to access more contextual information from each chunk when recalling information, but will result in more chunks being created and therefore increase memory backend usage and OpenAI API requests. Reducing the max_length value will create more chunks, which can save prompt tokens by allowing for more message history in the context, but will also increase the number of chunks. Increasing the max_length value will provide the AI with more contextual information from each chunk, reducing the number of chunks created and saving on OpenAI API requests. However, this may also use more prompt tokens and decrease the overall context available to the AI. Memory pre-seeding is a technique for improving AI accuracy by ingesting relevant data into its memory. Chunks of data are split and added to memory, allowing the AI to access them quickly and generate more accurate responses. It's useful for large datasets or when specific information needs to be accessed quickly. Examples include ingesting API or GitHub documentation before running Auto-GPT. Attention If you use Redis for memory, make sure to run Auto-GPT with WIPE_REDIS_ON_START=False For other memory backends, we currently forcefully wipe the memory when starting Auto-GPT. To ingest data with those memory backends, you can call the data_ingestion.py script anytime during an Auto-GPT run. Memories will be available to the AI immediately as they are ingested, even if ingested while Auto-GPT is running.","title":"Memory"},{"location":"configuration/memory/#setting-your-cache-type","text":"By default, Auto-GPT set up with Docker Compose will use Redis as its memory backend. Otherwise, the default is LocalCache (which stores memory in a JSON file). To switch to a different backend, change the MEMORY_BACKEND in .env to the value that you want: local uses a local JSON cache file pinecone uses the Pinecone.io account you configured in your ENV settings redis will use the redis cache that you configured milvus will use the milvus cache that you configured weaviate will use the weaviate cache that you configured","title":"Setting Your Cache Type"},{"location":"configuration/memory/#memory-backend-setup","text":"Links to memory backends Pinecone Milvus \u2013 self-hosted , or managed with Zilliz Cloud Redis Weaviate","title":"Memory Backend Setup"},{"location":"configuration/memory/#redis-setup","text":"Important If you have set up Auto-GPT using Docker Compose, then Redis is included, no further setup needed. Caution This setup is not intended to be publicly accessible and lacks security measures. Avoid exposing Redis to the internet without a password or at all! Launch Redis container docker run -d --name redis-stack-server -p 6379 :6379 redis/redis-stack-server:latest Set the following settings in .env MEMORY_BACKEND = redis REDIS_HOST = localhost REDIS_PORT = 6379 REDIS_PASSWORD = <PASSWORD> Replace <PASSWORD> by your password, omitting the angled brackets (<>). Optional configuration: WIPE_REDIS_ON_START=False to persist memory stored in Redis between runs. MEMORY_INDEX=<WHATEVER> to specify a name for the memory index in Redis. The default is auto-gpt . Info See redis-stack-server for setting a password and additional configuration.","title":"Redis Setup"},{"location":"configuration/memory/#pinecone-api-key-setup","text":"Pinecone lets you store vast amounts of vector-based memory, allowing the agent to load only relevant memories at any given time. Go to pinecone and make an account if you don't already have one. Choose the Starter plan to avoid being charged. Find your API key and region under the default project in the left sidebar. In the .env file set: PINECONE_API_KEY PINECONE_ENV (example: us-east4-gcp ) MEMORY_BACKEND=pinecone","title":"\ud83c\udf32 Pinecone API Key Setup"},{"location":"configuration/memory/#milvus-setup","text":"Milvus is an open-source, highly scalable vector database to store huge amounts of vector-based memory and provide fast relevant search. It can be quickly deployed with docker, or as a cloud service provided by Zilliz Cloud . Deploy your Milvus service, either locally using docker or with a managed Zilliz Cloud database: Install and deploy Milvus locally Set up a managed Zilliz Cloud database Go to Zilliz Cloud and sign up if you don't already have account. In the Databases tab, create a new database. Remember your username and password Wait until the database status is changed to RUNNING. In the Database detail tab of the database you have created, the public cloud endpoint, such as: https://xxx-xxxx.xxxx.xxxx.zillizcloud.com:443 . Run pip3 install pymilvus to install the required client library. Make sure your PyMilvus version and Milvus version are compatible to avoid issues. See also the PyMilvus installation instructions . Update .env : MEMORY_BACKEND=milvus One of: MILVUS_ADDR=host:ip (for local instance) MILVUS_ADDR=https://xxx-xxxx.xxxx.xxxx.zillizcloud.com:443 (for Zilliz Cloud) The following settings are optional : MILVUS_USERNAME='username-of-your-milvus-instance' MILVUS_PASSWORD='password-of-your-milvus-instance' MILVUS_SECURE=True to use a secure connection. Only use if your Milvus instance has TLS enabled. Note: setting MILVUS_ADDR to a https:// URL will override this setting. MILVUS_COLLECTION to change the collection name to use in Milvus. Defaults to autogpt .","title":"Milvus Setup"},{"location":"configuration/memory/#weaviate-setup","text":"Weaviate is an open-source vector database. It allows to store data objects and vector embeddings from ML-models and scales seamlessly to billion of data objects. To set up a Weaviate database, check out their Quickstart Tutorial . Although still experimental, Embedded Weaviate is supported which allows the Auto-GPT process itself to start a Weaviate instance. To enable it, set USE_WEAVIATE_EMBEDDED to True and make sure you pip install \"weaviate-client>=3.15.4\" .","title":"Weaviate Setup"},{"location":"configuration/memory/#install-the-weaviate-client","text":"Install the Weaviate client before usage. $ pip install weaviate-client","title":"Install the Weaviate client"},{"location":"configuration/memory/#setting-up-environment-variables","text":"In your .env file set the following: MEMORY_BACKEND = weaviate WEAVIATE_HOST = \"127.0.0.1\" # the IP or domain of the running Weaviate instance WEAVIATE_PORT = \"8080\" WEAVIATE_PROTOCOL = \"http\" WEAVIATE_USERNAME = \"your username\" WEAVIATE_PASSWORD = \"your password\" WEAVIATE_API_KEY = \"your weaviate API key if you have one\" WEAVIATE_EMBEDDED_PATH = \"/home/me/.local/share/weaviate\" # this is optional and indicates where the data should be persisted when running an embedded instance USE_WEAVIATE_EMBEDDED = False # set to True to run Embedded Weaviate MEMORY_INDEX = \"Autogpt\" # name of the index to create for the application","title":"Setting up environment variables"},{"location":"configuration/memory/#view-memory-usage","text":"View memory usage by using the --debug flag :)","title":"View Memory Usage"},{"location":"configuration/memory/#memory-pre-seeding","text":"Memory pre-seeding allows you to ingest files into memory and pre-seed it before running Auto-GPT. $ python data_ingestion.py -h usage: data_ingestion.py [ -h ] ( --file FILE | --dir DIR ) [ --init ] [ --overlap OVERLAP ] [ --max_length MAX_LENGTH ] Ingest a file or a directory with multiple files into memory. Make sure to set your .env before running this script. options: -h, --help show this help message and exit --file FILE The file to ingest. --dir DIR The directory containing the files to ingest. --init Init the memory and wipe its content ( default: False ) --overlap OVERLAP The overlap size between chunks when ingesting files ( default: 200 ) --max_length MAX_LENGTH The max_length of each chunk when ingesting files ( default: 4000 ) # python data_ingestion.py --dir DataFolder --init --overlap 100 --max_length 2000 In the example above, the script initializes the memory, ingests all files within the Auto-Gpt/autogpt/auto_gpt_workspace/DataFolder directory into memory with an overlap between chunks of 100 and a maximum length of each chunk of 2000. Note that you can also use the --file argument to ingest a single file into memory and that data_ingestion.py will only ingest files within the /auto_gpt_workspace directory. The DIR path is relative to the auto_gpt_workspace directory, so python data_ingestion.py --dir . --init will ingest everything in auto_gpt_workspace directory. You can adjust the max_length and overlap parameters to fine-tune the way the documents are presented to the AI when it \"recall\" that memory: Adjusting the overlap value allows the AI to access more contextual information from each chunk when recalling information, but will result in more chunks being created and therefore increase memory backend usage and OpenAI API requests. Reducing the max_length value will create more chunks, which can save prompt tokens by allowing for more message history in the context, but will also increase the number of chunks. Increasing the max_length value will provide the AI with more contextual information from each chunk, reducing the number of chunks created and saving on OpenAI API requests. However, this may also use more prompt tokens and decrease the overall context available to the AI. Memory pre-seeding is a technique for improving AI accuracy by ingesting relevant data into its memory. Chunks of data are split and added to memory, allowing the AI to access them quickly and generate more accurate responses. It's useful for large datasets or when specific information needs to be accessed quickly. Examples include ingesting API or GitHub documentation before running Auto-GPT. Attention If you use Redis for memory, make sure to run Auto-GPT with WIPE_REDIS_ON_START=False For other memory backends, we currently forcefully wipe the memory when starting Auto-GPT. To ingest data with those memory backends, you can call the data_ingestion.py script anytime during an Auto-GPT run. Memories will be available to the AI immediately as they are ingested, even if ingested while Auto-GPT is running.","title":"\ud83e\udde0 Memory pre-seeding"},{"location":"configuration/search/","text":"\ud83d\udd0d Google API Keys Configuration Note This section is optional. Use the official Google API if search attempts return error 429. To use the google_official_search command, you need to set up your Google API key in your environment variables. Create your project: Go to the Google Cloud Console . If you don't already have an account, create one and log in Create a new project by clicking on the Select a Project dropdown at the top of the page and clicking New Project Give it a name and click Create Set up a custom search API and add to your .env file: Go to the APIs & Services Dashboard Click Enable APIs and Services Search for Custom Search API and click on it Click Enable Go to the Credentials page Click Create Credentials Choose API Key Copy the API key Set it as the GOOGLE_API_KEY in your .env file Enable the Custom Search API on your project. (Might need to wait few minutes to propagate.) Set up a custom search engine and add to your .env file: Go to the Custom Search Engine page Click Add Set up your search engine by following the prompts. You can choose to search the entire web or specific sites Once you've created your search engine, click on Control Panel Click Basics Copy the Search engine ID Set it as the CUSTOM_SEARCH_ENGINE_ID in your .env file Remember that your free daily custom search quota allows only up to 100 searches. To increase this limit, you need to assign a billing account to the project to profit from up to 10K daily searches.","title":"Search"},{"location":"configuration/search/#google-api-keys-configuration","text":"Note This section is optional. Use the official Google API if search attempts return error 429. To use the google_official_search command, you need to set up your Google API key in your environment variables. Create your project: Go to the Google Cloud Console . If you don't already have an account, create one and log in Create a new project by clicking on the Select a Project dropdown at the top of the page and clicking New Project Give it a name and click Create Set up a custom search API and add to your .env file: Go to the APIs & Services Dashboard Click Enable APIs and Services Search for Custom Search API and click on it Click Enable Go to the Credentials page Click Create Credentials Choose API Key Copy the API key Set it as the GOOGLE_API_KEY in your .env file Enable the Custom Search API on your project. (Might need to wait few minutes to propagate.) Set up a custom search engine and add to your .env file: Go to the Custom Search Engine page Click Add Set up your search engine by following the prompts. You can choose to search the entire web or specific sites Once you've created your search engine, click on Control Panel Click Basics Copy the Search engine ID Set it as the CUSTOM_SEARCH_ENGINE_ID in your .env file Remember that your free daily custom search quota allows only up to 100 searches. To increase this limit, you need to assign a billing account to the project to profit from up to 10K daily searches.","title":"\ud83d\udd0d Google API Keys Configuration"},{"location":"configuration/voice/","text":"Text to Speech Enter this command to use TTS (Text-to-Speech) for Auto-GPT python -m autogpt --speak Eleven Labs provides voice technologies such as voice design, speech synthesis, and premade voices that Auto-GPT can use for speech. Go to ElevenLabs and make an account if you don't already have one. Choose and setup the Starter plan. Click the top right icon and find Profile to locate your API Key. In the .env file set: ELEVENLABS_API_KEY ELEVENLABS_VOICE_1_ID (example: \"premade/Adam\" ) List of available voices Note You can use either the name or the voice ID to configure a voice Name Voice ID Rachel 21m00Tcm4TlvDq8ikWAM Domi AZnzlk1XvdvUeBnXmlld Bella EXAVITQu4vr4xnSDxMaL Antoni ErXwobaYiN019PkySvjV Elli MF3mGyEYCl7XYWbV9V6O Josh TxGEqnHWrfWFTfGW9XjX Arnold VR6AewLTigWG4xSOukaG Adam pNInz6obpgDQGcFmaJgB Sam yoZ06aMxZJJ28mfd3POQ","title":"Voice"},{"location":"configuration/voice/#text-to-speech","text":"Enter this command to use TTS (Text-to-Speech) for Auto-GPT python -m autogpt --speak Eleven Labs provides voice technologies such as voice design, speech synthesis, and premade voices that Auto-GPT can use for speech. Go to ElevenLabs and make an account if you don't already have one. Choose and setup the Starter plan. Click the top right icon and find Profile to locate your API Key. In the .env file set: ELEVENLABS_API_KEY ELEVENLABS_VOICE_1_ID (example: \"premade/Adam\" )","title":"Text to Speech"},{"location":"configuration/voice/#list-of-available-voices","text":"Note You can use either the name or the voice ID to configure a voice Name Voice ID Rachel 21m00Tcm4TlvDq8ikWAM Domi AZnzlk1XvdvUeBnXmlld Bella EXAVITQu4vr4xnSDxMaL Antoni ErXwobaYiN019PkySvjV Elli MF3mGyEYCl7XYWbV9V6O Josh TxGEqnHWrfWFTfGW9XjX Arnold VR6AewLTigWG4xSOukaG Adam pNInz6obpgDQGcFmaJgB Sam yoZ06aMxZJJ28mfd3POQ","title":"List of available voices"}]}